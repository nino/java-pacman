package Pacman.Model;

import java.util.LinkedList;
import java.util.Random;

import Pacman.PacMan;
import Pacman.lib.Vector;

/**
 * This class controls the ghost entities in the game.
 */
public final class Ghost extends GameCharacter  {
	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = -8247574508495075853L;

	/**
	 * When a ghost is killed, it will hibernate for this amount if time (in ms).
	 */
	public static final int deathTime = 5000;

	/**
	 * Stores whether the ghost is currently dead.
	 */
	private boolean dead;

	/**
	 * There are four ghost types.
	 * They only differ in the image that is drawn to represent them in the view.
	 */
	private int ghostType;
	
	/**
	 * Initializes variables and the thread.
	 */
	public Ghost() {
		thread = new Thread(this);
		active = false;
		dead = false;
		speed = 100;
		direction = new Vector(1.0, 0.0);
		ghostType = 0;
	}

	/**
	 * The {@code run} method for the {@link Runnable} interface.
	 */
	@Override
		public void run() {
			while (active) {
				if (dead) {
					try {
						Thread.sleep(Ghost.deathTime);
					} catch (Exception e) {
						System.err.println("Sleep of death interrupted");
					}
					dead = false;
				}
	
				this.step();
				try {
					Thread.sleep(1000/this.speed);
				} catch (Exception e) {
					System.err.println("Ghost thread interrupted");
				}
			}
		}

	/**
	 * @return dead
	 */
	public boolean getDead() {
		return dead;
	}

	/**
	 * @return the ghostType
	 */
	public int getGhostType() {
		return ghostType;
	}

	/**
	 * Sets active to true and signals the thread to start.
	 */
	@Override
	void startCharacter() {
			active = true;
			thread = new Thread(this);
			thread.start();
		}

	/**
	 * move Ghost one step and possibly change direction, if possible.
	 * @return Whether the ghost has moved or not
	 */
	@Override
	boolean step() {
		if(PacMan.getGame().getMap().passMapBlockCentre(this.position, this.direction.scale(this.stepSize))) {
			this.nextTurn = generateNewDirection().getDirection();
		}
		
		//If direction has changed, the Ghosts goes in the original direction until he reaches the center of the mapblock and then goes the rest in the new direction.	
		LinkedList<Vector> result = this.turn(this.getPosition(), nextTurn);
		Vector newPosition = result.get(0);
		this.direction = result.get(1);
		if(result.get(2) != null) this.nextTurn = result.get(2).getDirection();
		
		double offset = newPosition.distance(this.position); // distance to go in the original direction
		
		
		//if Ghost reaches center of MapBlock, check collision of next block
		if(this.mapCollisionNextBlock(newPosition, this.direction))
			return false;
		
		newPosition = new Vector(newPosition.add(direction.scale(stepSize - offset)).constrainToMap());
	
		// Map collision
		if(this.mapCollision(newPosition))
			return false;
	
		this.position = newPosition;
		return true;
	}

	/**
	 * To check if there will be a collision on the next step, a proxyGhost is generated to simulate the step
	 * without the actual ghost actually moving.
	 */
	@Override
	boolean simulateStep(Vector position, Vector newDirection) {
		//simulate step for collision control
		Vector newPosition = PacMan.getGame().getMap().getMapBlockCentre(position, this.direction.getDirection()); //set proxyGhost to center of MapBlock to avoid problems with passMapBlockCentre() called in proxyPlayer.step(). Not needed with current implementation of passMapBlockCentre(). 
		Ghost proxyGhost = new Ghost();
		proxyGhost.setPosition(newPosition);
		proxyGhost.setDirection(newDirection);	
		
		return proxyGhost.step();
	}

	/**
	 * Sets dead to true and teleports the ghost to the ghostSpawnPoint.
	 */
	@Override
		void die() {
			dead = true;
			this.setPosition(PacMan.getGame().getMap().getGhostSpawnVector());
		}

	/**
	 * Sets active to false so the thread doesn't keep moving the ghost.
	 */
	@Override
	void stop() {
			active = false;
		}

	/**
	 * @param ghostType the ghostType to set
	 */
	void setGhostType(int ghostType) {
		this.ghostType = ghostType;
	}

	/**
	 * When stepping, the ghost checks in which directions it could go. These are returned here.
	 *
	 * @return possible directions where the ghost could go next.
	 */
	private Vector[] possibleNewDirections() {
		Vector[] possibleDirections;
		boolean straight = false;
		boolean turnOne = false;
		Vector directionOne = new Vector(direction.getY(), direction.getX());
		boolean turnTwo = false;
		Vector directionTwo = new Vector(-direction.getY(), -direction.getX());
		boolean backward = false;
		Vector directionBackward = new Vector(-direction.getX(), -direction.getY());
		int length = 0; // length of the vector array
		                // to help with the initialization

		if (!mapCollision(position.add(direction.scale(stepSize)).constrainToMap())) {
			straight = true;
			length += 1;
		}
		if (!mapCollision(position.add(directionOne.scale(stepSize)).constrainToMap())) {
			turnOne = true;
			length += 1;
		}
		if (!mapCollision(position.add(directionTwo.scale(stepSize)).constrainToMap())) {
			turnTwo = true;
			length += 1;
		}
		if (!mapCollision(position.add(directionBackward.scale(stepSize)).constrainToMap()) && straight == false) {
			backward = true;
			length += 1;
		}

		possibleDirections = new Vector[length];
		int index = 0;
		if (straight)
			possibleDirections[index++] = direction;
		if (turnOne)
			possibleDirections[index++] = directionOne;
		if (turnTwo)
			possibleDirections[index++] = directionTwo;
		if (backward)
			possibleDirections[index++] = directionBackward;


		return possibleDirections;
	}

	/**
	 * From all possible directions where the ghost could go, this method chooses one at random.
	 */
	private Vector generateNewDirection() {
		Vector[] possibleNewDirections = possibleNewDirections();
		if (possibleNewDirections.length > 0) {
			Random rand = new Random();
			int randomIndex = Math.abs(rand.nextInt() % possibleNewDirections.length);
			return possibleNewDirections[randomIndex];
		}
		else {
			return null;
		}
	}

}
