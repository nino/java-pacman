package Pacman.Model;

import java.io.Serializable;

import Pacman.PacMan;
import Pacman.lib.Vector;
import Pacman.lib.Direction;
import Pacman.Model.MapBlocks.*;

/**
 * The map class stores map information.
 * 
 * GameCharacters will use the Map object to check for collisions and the gui
 * will use the Map object to render the game level.
 */
public final class Map implements Serializable {
	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = 4043153580284980775L;

	// public constants
	
	/**
	 * The width of the map in mapBlocks
	 */
	public final static int mapSizeX = 16;
	
	/**
	 * The height of the map in mapBlocks
	 */
	public final static int mapSizeY = 16;

	/**
	 * The number of ghosts in the game
	 */
	private final int ghostCount = 4;

	/**
	 * The blocks that make up the map
	 */
	private MapBlock[][] blocks;

	/**
	 * The point where ghosts are spawned, expressed in
	 * grid coordinates.
	 */
	private int[] ghostSpawnPoint;

	/**
	 * The point where the player is spawned, expressed in
	 * grid coordinates.
	 */
	private int[] playerSpawnPoint;

	/**
	 * How many dots are left for the player to eat.
	 */
	private int dotsLeft;

	/**
	 * default constructor populates map with empty blocks
	 */
	public Map() {
		this.blocks = new MapBlock[mapSizeX][mapSizeY];
		for (int i = 0; i < mapSizeY; i++) {
			for (int j = 0; j < mapSizeY; j++) {
				blocks[i][j] = Dot.getInstance();
			}
		}

		ghostSpawnPoint = new int[2];
		ghostSpawnPoint[0] = 10;
		ghostSpawnPoint[1] = 10;
		playerSpawnPoint = new int[2];
		playerSpawnPoint[0] = 0;
		playerSpawnPoint[1] = 0;
		dotsLeft = 0;
	}

	/**
	 * clone constructor
	 * 
	 * This constructs a new map objects containing
	 * all the information of another map.
	 *
	 * @param o Map that is to be cloned
	 */
	public Map(Map o) {
		if (blocks == null)
			blocks = new MapBlock[mapSizeX][mapSizeY];
		for (int y = 0; y < mapSizeY; y++) {
			for (int x = 0; x < mapSizeX; x++) {
				blocks[x][y] = o.getBlocks()[x][y];
			}
		}
		playerSpawnPoint = o.getPlayerSpawn().clone();
		ghostSpawnPoint = o.getGhostSpawn().clone();
		computeDotsLeft();
	}

	/**
	 * Sets {@link Map#ghostSpawnPoint}
	 */
	public void setGhostSpawn(int[] gridPosition) {
		ghostSpawnPoint = gridPosition;
	}

	/**
	 * Sets {@link Map#playerSpawnPoint}
	 */
	public void setPlayerSpawn(int[] gridPosition) {
		playerSpawnPoint = gridPosition;
	}

	/**
	 * Sets a specific item of {@link Map#blocks}
	 */
	public void setBlock(int[] gridPosition, MapBlock block) {
		blocks[gridPosition[0]][gridPosition[1]] = block;
	}

	/**
	 * The blocks are what the map is made of.
	 * 
	 * Some types of block are Wall, Dot, Empty ...
	 */
	public MapBlock[][] getBlocks() {
		return blocks;
	}


	/**
	 * Converts a Vector to an int array that signifies the position on the map
	 * grid
	 */
	public int[] getGridPosition(Vector position) {
		int[] gridPos = { (int) (position.getX() + 0.9),
				(int) (position.getY() + 0.9) };
		return gridPos;
	}

	/**
	 * @return {@link Map#playerSpawnPoint} as a {@link Vector}
	 */
	public Vector getPlayerSpawnVector() {
		Vector v = new Vector((double) playerSpawnPoint[0],
				(double) playerSpawnPoint[1]);
		return v;
	}

	/**
	 * Gets {@link Map#playerSpawnPoint}
	 */
	public int[] getPlayerSpawn() {
		return playerSpawnPoint;
	}

	/**
	 * @return {@link Map#ghostSpawnPoint} as a {@link Vector}
	 */
	public Vector getGhostSpawnVector() {
		Vector v = new Vector((double) ghostSpawnPoint[0],
				(double) ghostSpawnPoint[1]);
		return v;
	}

	/**
	 * Gets {@link Map#ghostSpawnPoint}
	 */
	public int[] getGhostSpawn() {
		return ghostSpawnPoint;
	}

	/**
	 * @return the ghostCount
	 */
	public int getGhostCount() {
		return ghostCount;
	}

	/**
	 * Get {@link Map#dotsLeft}
	 */
	public int getDotsLeft() {
		return dotsLeft;
	}

	/**
	 * Returns true if position is at the centre of a MapBlock or if the center
	 * is passed when performing a step
	 * 
	 * @param position
	 *            Original position to check
	 * @param step
	 *            Step to go
	 */
	public boolean passMapBlockCentre(Vector position, Vector step) {
		// position is at centre
		if (position.getX() == Math.floor(position.getX())
				&& position.getY() == Math.floor(position.getY()))
			return true;

		Vector newPosition = position.add(step).constrainToMap();

		// centre is passed during step
		if (Math.floor(newPosition.getX()) != Math.floor(position.getX())
				|| Math.floor(newPosition.getY()) != Math
						.floor(position.getY()))
			return true;

		return false;

	}

	/**
	 * Returns the coordinates of the next MapBlock center you pass when going
	 * from position in the given direction.
	 * <p>
	 * Compared to the {@link #getNextMapBlock(Vector, Vector)} method, this
	 * method can return the coordinates of the MapBlock in which
	 * {@code position} is situated. In this case it returns the same value as
	 * {@code getGridPosition(position)}.
	 * 
	 * @param position
	 * @param direction
	 * @see #getGridPosition(Vector)
	 */
	public Vector getMapBlockCentre(Vector position, Direction direction) {
		switch (direction) {
		case DOWN:
			position.setY(Math.ceil(position.getY()));
			break;
		case UP:
			position.setY(Math.floor(position.getY()));
			break;
		case LEFT:
			position.setX(Math.floor(position.getX()));
			break;
		case RIGHT:
			position.setX(Math.ceil(position.getX()));
			break;
		}
		return position;
	}

	/**
	 * Returns coordinates of the neighbor MapBlock in the given
	 * {@code direction}.
	 * <p>
	 * Compared to the {@link #getMapBlockCentre(Vector, Direction)} method,
	 * this method <i>never</i> returns the coordinates of the MapBlock in which
	 * {@code position} is situated.
	 * 
	 * @param position
	 *            Position to check.
	 * @param direction
	 *            Direction to go from position.
	 */
	public Vector getNextMapBlock(Vector position, Vector direction) {
		int[] gridPosition = PacMan.getGame().getMap()
				.getGridPosition(position);
		Vector roundedPosition = new Vector(new Double(gridPosition[0]),
				new Double(gridPosition[1]));
		Vector nextGridPosition = roundedPosition.add(direction.normalize());
		return nextGridPosition;
	}
	/**
	 * Calculates how many dots are left to eat, before the game is won.
	 */
	public void computeDotsLeft() {
		dotsLeft = 0;
		for (int y = 0; y < mapSizeY; y++)
			for (int x = 0; x < mapSizeX; x++)
				if (blocks[x][y].getClass() == Dot.getInstance().getClass())
					dotsLeft++;
	}

	/**
	 * @return Whether the block at the provided {@code position}
	 * can be eaten by the player
	 */
	boolean eat(Vector position) {
		int[] gridPos = this.getGridPosition(position);
		return blocks[gridPos[0]][gridPos[1]].isEatable();
	}

	/**
	 * @return Whether the block at the provided {@code position}
	 * can collide with the player or ghosts.
	 */
	boolean collision(Vector position) {
		int[] gridPos = this.getGridPosition(position);
		// System.out.println(gridPos);
		// System.out.println(blocks[gridPos[0]][gridPos[1]].collision());
	
		return blocks[gridPos[0]][gridPos[1]].canCollide();
	}

	/**
	 * @return Whether the block at the provided {@code position}
	 * will enable special item mode, once eaten
	 */
	boolean special(Vector position) {
		int[] gridPos = this.getGridPosition(position);
		return (blocks[gridPos[0]][gridPos[1]].getClass() == Special.getInstance().getClass());
	}
}
