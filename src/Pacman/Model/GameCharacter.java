package Pacman.Model;

import java.io.Serializable;
import java.util.LinkedList;

import Pacman.PacMan;
import Pacman.lib.*;

/**
 * This is the parent class for the {@link Ghost} and {@link Player} classes.
 */
public abstract class GameCharacter implements GameCharacterInterface,
		Runnable, Serializable {

	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = 7912879199590140180L;

	/**
	 * This controls how much the position vector is displaced with each step the character takes.
	 */
	protected final double stepSize = 0.01;

	/**
	 * Vector of position of GameCharacter
	 */
	protected Vector position;

	/**
	 * Vector that points in the direction of movement. Should be normed!
	 */
	protected Vector direction;

	/**
	 * flag, whether the character is currently active (mostly for the thread)
	 */
	protected boolean active;

	/**
	 * speed of the character. Used for sleep time in the thread
	 */
	protected long speed;

	/**
	 * when the user presses an arrow key or the ghost changes the direction,
	 * this variable will be set and the player will then turn in that direction
	 * at the next possible opportunity
	 */
	protected Direction nextTurn;

	/**
	 * Thread to compute movement. This way, the characters can start and stop
	 * themselves
	 */
	protected transient Thread thread;

	/**
	 * @return the direction
	 */
	public Vector getDirection() {
		return direction;
	}

	/**
	 * Getter for {@link GameCharacter#speed}
	 *
	 * @return the speed
	 */
	public double getSpeed() {
		return speed;
	}


	/**
	 * Getter method for Position.
	 * 
	 * @return position Vector
	 */
	public Vector getPosition() {
		return this.position;
	}

	/**
	 * Implementation of the <code>run</code> method for the {@link Runnable} interface.
	 */
	public abstract void run();


	/**
	 * Performs a step in the direction of movement, if possible.
	 * 
	 * @return Returns true if step is done, false if GameCharacter collides.
	 */
	abstract boolean step();

	/**
	 * Simulates as step in the given direction.
	 * <p>
	 * Note: When implementing, make sure the call of the {@link #step()} method
	 * does not create infinite loop.
	 * 
	 * @param position
	 *            The position of the GameCharacter.
	 * @param newDirection
	 *            The direction to go.
	 * @return true, if GameCharacter can do a step without colliding.
	 */
	abstract boolean simulateStep(Vector position, Vector newDirection);

	/**
	 * Setter for {@link GameCharacter#direction}
	 *
	 * @param direction
	 *            the direction to set
	 */
	void setDirection(Vector direction) {
		this.direction = direction;
	}

	/**
	 * Checks if the GameCharacter can turn into the given {@code direction}.<br>
	 * Calls {@link #simulateStep(Vector, Vector)} method of {@code sender}.
	 * 
	 * @param direction
	 *            The direction to turn to.
	 * @param sender
	 *            The GameCharacter that turns.
	 * @return true, if GameCharacter can turn.
	 */
	boolean canTurn(Direction direction, GameCharacter sender) {
		Vector newDirection;
		newDirection = new Vector(direction);
	
		// compare newDirection with players movement direction
		if (newDirection.equals(this.getDirection()))
			return false; // no need to change direction
		if (newDirection.scale(-1).equals(this.getDirection()))
			return true; // always allowed to turn to opposite direction
	
		// player can only change the direction if it's at the center of a
		// MapBlock or pass it with the next step.
		if (PacMan.getGame().getMap()
				.passMapBlockCentre(position, this.direction.scale(stepSize))) {
			if (sender.simulateStep(position, newDirection))
				return true; // only change direction when player doesn't
								// collide on next step
		}
	
		return false;
	}

	/**
	 * Turns if possible and corrects the position of a GameCharacter to make
	 * sure, it moves along map grid.
	 * 
	 * @param newPosition
	 *            The position of the GameCharacter.
	 * @param nextTurn
	 *            The next turn to do.
	 * @return LinkedList of Vectors<br>
	 *         First element: the corrected position<br>
	 *         Second element: The new direction of movement (as Vector).<br>
	 *         Third element: The next turn (as Vector).
	 */
	LinkedList<Vector> turn(Vector newPosition, Direction nextTurn) {
		LinkedList<Vector> result = new LinkedList<Vector>();
		if (nextTurn != null) { // change the direction
			if (this.canTurn(nextTurn, this)) {
				if (nextTurn != this.direction.scale(-1).getDirection()) { // don't
																			// correct
																			// the
																			// player's
																			// position
																			// if
																			// nextTurn
																			// is
																			// opposite
																			// direction
																			// of
																			// original
																			// movement
																			// direction
					// make sure the player stays in the middle of
					// corridors/MapBlocks
					newPosition = PacMan
							.getGame()
							.getMap()
							.getMapBlockCentre(newPosition,
									this.direction.getDirection());
				}
				result.add(new Vector(nextTurn));
				result.add(null);
			} else {
				result.add(this.direction);
				result.add(new Vector(nextTurn));
			}
		} else {
			result.add(this.direction);
			result.add(null);
		}
		result.addFirst(newPosition);
		return result;
	}

	/**
	 * Checks if the GameCharacter collides with the next MapBlock in the given
	 * {@code direction}.
	 * 
	 * @param position
	 *            The position of the GameCharacter
	 * @param direction
	 *            The direction of movement
	 * @return true, if GameCharacter collides
	 */
	boolean mapCollisionNextBlock(Vector position, Vector direction) {
		// if Player reaches center of MapBlock, check collision of next block
		if (PacMan.getGame().getMap()
				.passMapBlockCentre(position, direction.scale(stepSize))) {
			Vector newGridPosition = PacMan.getGame().getMap()
					.getNextMapBlock(position, direction).constrainToMap();
			return PacMan.getGame().getMap().collision(newGridPosition);
		}
		return false;
	}

	/**
	 * Checks if the GameCharacter collides with the MapBlock at the given
	 * {@code position}.
	 * 
	 * @param position
	 *            The position if the GameCharacter
	 * @return true, if GameCharacter collides
	 */
	boolean mapCollision(Vector position) {
		return PacMan.getGame().getMap().collision(position);
	}

	/**
	 * Getter for {@link GameCharacter#active}
	 */
	boolean getActive() {
		return active;
	}

	/**
	 * Sets position to target
	 * 
	 * @param target
	 *            Vector of new position
	 */
	void setPosition(Vector target) {
		this.position = target;
	}

	/**
	 * This starts the character, which means the thread is started and the state changes
	 */
	abstract void startCharacter();

	/**
	 * This starts the character, which only means that the state changes, the thread continues to run.
	 */
	abstract void stop();

	/**
	 * The character dies. This has different effects, whether the character is a ghost or the player.
	 */
	abstract void die();

}
